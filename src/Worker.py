# -*- generated by 1.0.4 -*-
import da
PatternExpr_632 = da.pat.TuplePattern([da.pat.ConstantPattern('terminate')])
PatternExpr_658 = da.pat.TuplePattern([da.pat.ConstantPattern('evaluate_policy'), da.pat.FreePattern('request')])
PatternExpr_665 = da.pat.FreePattern('Coordinator')
PatternExpr_637 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.TuplePattern([da.pat.ConstantPattern('terminate')])])
_config_object = {}
import xml.etree.ElementTree as ET
from configparser import ConfigParser
import time

class Worker(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._WorkerReceivedEvent_0 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_WorkerReceivedEvent_0', PatternExpr_632, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_WorkerReceivedEvent_1', PatternExpr_658, sources=[PatternExpr_665], destinations=None, timestamps=None, record_history=None, handlers=[self._Worker_handler_657])])

    def setup(self, worker_id, coordinator_dict, client_dict, dedicated_workers_dict, config_file, database, **rest_1153):
        super().setup(worker_id=worker_id, coordinator_dict=coordinator_dict, client_dict=client_dict, dedicated_workers_dict=dedicated_workers_dict, config_file=config_file, database=database, **rest_1153)
        self._state.worker_id = worker_id
        self._state.coordinator_dict = coordinator_dict
        self._state.client_dict = client_dict
        self._state.dedicated_workers_dict = dedicated_workers_dict
        self._state.config_file = config_file
        self._state.database = database
        self.output('Setting up Worker...')
        self._state.worker_id = self._state.worker_id
        self._state.coordinator_dict = self._state.coordinator_dict
        self._state.client_dict = self._state.client_dict
        self._state.dedicated_workers_dict = self._state.dedicated_workers_dict
        self._state.config_file = self._state.config_file
        self._state.database = self._state.database
        self._state.policy_file = ''
        self._state.global_dict = dict()
        self._state.cached_data = dict()
        self._state.readAttr = {}
        self._state.sleep_time = 0

    def run(self):
        self.get_configuration()
        self.output((('Worker Process ' + str(self._state.worker_id)) + ' coming up...'))
        super()._label('_st_label_629', block=False)
        _st_label_629 = 0
        while (_st_label_629 == 0):
            _st_label_629 += 1
            if PatternExpr_637.match_iter(self._WorkerReceivedEvent_0, SELF_ID=self._id):
                _st_label_629 += 1
            else:
                super()._label('_st_label_629', block=True)
                _st_label_629 -= 1
        self.output((('Terminated Worker: ' + str(self._state.worker_id)) + ' ...'))

    def evaluate_policy(self, request, file_path):
        tree = ET.parse(file_path)
        root = tree.getroot()
        dict = {}
        data = None
        count = 0
        data = request['res_cache_updates']
        for rule in root.iter('rule'):
            sub_id = ''
            res_id = ''
            balance = ''
            count += 1
            read_attribute = []
            sc = rule[0].attrib
            if sc:
                sub_id = sc['customer_id']
                if ('history' in sc):
                    history = sc['history']
                    read_attribute.append('history')
                if ('status' in sc):
                    status = 'status'
                    read_attribute.append('status')
            self._state.readAttr['subject'] = read_attribute
            read_attribute = []
            rc = rule[1].attrib
            if rc:
                res_id = rc['account_id']
                if ('balance' in rc):
                    balance = rc['account_bal']
                    self._state.readAttr.append('account_bal')
            self._state.readAttr['resource'] = read_attribute
            if (('<' in balance) or ('>' in balance)):
                if ('<' in balance):
                    if (balance < data[0][1]):
                        self.output('Balance checked')
                    else:
                        return None
                elif (balance > data[0][1]):
                    self.output('Balance checked')
                else:
                    return None
            act = rule.find('action')
            action = act.attrib['name']
            if (len(rule) == 4):
                if ('subjectUpdate' in rule[3].tag):
                    su = rule[3]
                    update_tuple = ()
                    if ('history' in su.attrib):
                        val = su.attrib['history']
                        if ((not (val.find('$') == (- 1))) and ('_id' in val)):
                            update_tuple = ('history', res_id)
                    elif ('status' in su.attrib):
                        val = su.attrib['status']
                        update_tuple = ('status', val)
                    dict.update({(sub_id, res_id, action): ('subjectUpdate', update_tuple)})
                elif ('resourceUpdate' in rule[3].tag):
                    ru = rule[3]
                    if (data and (len(data) > 2)):
                        account_bal = data[0][1]
                    else:
                        account_bal = 0
                    if ('++' in ru.attrib['account_bal']):
                        account_bal += int(ru.attrib['account_bal'].replace('++', ''))
                    elif ('--' in ru.attrib['account_bal']):
                        account_bal -= int(ru.attrib['account_bal'].replace('--', ''))
                    dict.update({(sub_id, res_id, action): ('resourceUpdate', ('account_bal', account_bal))})
            else:
                dict.update({(sub_id, res_id, action): ''})
        self.output(('Dictionary: ' + str(dict)))
        return dict

    def get_configuration(self):
        self.output('Reading Configuration from properties file')
        config = ConfigParser()
        config.read(self._state.config_file)
        self._state.policy_file = config.get('SystemConfiguration', 'policy_file')
        self._state.sleep_time = config.get('SystemConfiguration', 'sleep_time')

    def _Worker_handler_657(self, request, Coordinator):
        self.output((((((((((('Worker ' + str(self._state.worker_id)) + ' Received Policy Evaluation [Request: ') + str(request['req_id'])) + ' , Client: ') + str(request['client_id'])) + '] with [Coordinator-1: ') + str(request['coord_id1'])) + ' , Coordinator-2: ') + str(request['coord_id2'])) + ']'))
        self.output(('Request Message: ' + str(request)))
        config = ConfigParser()
        config.read(self._state.config_file)
        zero_latency = int(config.get('SystemConfiguration', 'zero_latency'))
        if (zero_latency == 1):
            req_id = request['req_id']
            self.output('zero_latency set to evaluate performance')
            request.update({'decision': 'True'})
            if (request['action_id'] == 'read'):
                self.send(('decision-perf-eval', req_id), to=self._state.client_dict[request['client_id']])
            elif (request['action_id'] == 'update'):
                client_prediction = int(config.get('SystemConfiguration', 'client_prediction'))
                if (client_prediction == 1):
                    self.output('client prediction true: sending to coord2')
                    self.send(('update-decision-perf-eval', request), to=self._state.coordinator_dict[request['coord_id2']])
                else:
                    self.output('client prediction flase: sending to coord1')
                    self.send(('update-decision-perf-eval', request), to=self._state.coordinator_dict[request['coord_id1']])
        else:
            self._state.global_dict = self.evaluate_policy(request, self._state.policy_file)
        if ((request['subject_id'], request['resource_id'], request['action_id']) in self._state.global_dict):
            request.update({'decision': 'True'})
            update_object = self._state.global_dict[(request['subject_id'], request['resource_id'], request['action_id'])]
        else:
            request.update({'decision': 'False'})
            update_object = ''
        if ('' in update_object):
            request.update({'updatedObj': ''})
            request.update({'readonlyObj': ''})
        elif ('subject' in update_object[0]):
            request.update({'updatedObj': 'subject'})
            request.update({'updatedAttr': update_object[1]})
            request.update({'readonlyObj': 'resource'})
        else:
            request.update({'updatedObj': 'resource'})
            request.update({'updatedAttr': update_object[1]})
            request.update({'readonlyObj': 'subject'})
        prediction = True
        if (not ('' in update_object)):
            if (request['might_update_obj'] == request['updatedObj']):
                prediction = True
            else:
                prediction = False
                if (not (request['coord_id1'] == request['coord_id2'])):
                    request['coord_id1'] = request['wrong_coord']
            self.output(('Result of Prediction: ' + str(prediction)))
        self.output('Piggyback Data')
        request.update({('readAttr' + 'subject'): self._state.readAttr['subject']})
        request.update({('readAttr' + 'resource'): self._state.readAttr['resource']})
        if (request['client_id'] == 1):
            time.sleep(int(self._state.sleep_time))
        if ('' in update_object):
            self.send(('read-decision', request['req_id'], request['decision']), to=self._state.client_dict[request['client_id']])
            request.update({'object': 'subject'})
            self.send(('update-decision', request), to=self._state.coordinator_dict[request['coord_id1']])
            request.update({'object': 'resource'})
            self.send(('update-decision', request), to=self._state.coordinator_dict[request['coord_id2']])
        else:
            request.update({'object': request['updatedObj']})
            if prediction:
                self.output(('Sending Update Decision to Coordinator: ' + str(request['coord_id2'])))
                self.send(('update-decision', request), to=self._state.coordinator_dict[request['coord_id2']])
            else:
                self.output('Prediction of client was False.')
                self.output(('Received Update Decision Request from Coordinator: ' + str(request['coord_id2'])))
                self.output(('Sending Update Decision to Coordinator: ' + str(request['coord_id1'])))
                self.send(('update-decision', request), to=self._state.coordinator_dict[request['coord_id1']])
    _Worker_handler_657._labels = None
    _Worker_handler_657._notlabels = None
