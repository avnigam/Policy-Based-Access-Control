# -*- generated by 1.0.4 -*-
import da
PatternExpr_462 = da.pat.TuplePattern([da.pat.ConstantPattern('cached')])
PatternExpr_1110 = da.pat.TuplePattern([da.pat.ConstantPattern('terminate')])
PatternExpr_1176 = da.pat.TuplePattern([da.pat.ConstantPattern('dump_sent'), da.pat.FreePattern('data')])
PatternExpr_1183 = da.pat.FreePattern('Database')
PatternExpr_1411 = da.pat.TuplePattern([da.pat.ConstantPattern('coord1_policy_eval'), da.pat.FreePattern('request')])
PatternExpr_1418 = da.pat.FreePattern('Client')
PatternExpr_1789 = da.pat.TuplePattern([da.pat.ConstantPattern('coord2_policy_eval'), da.pat.FreePattern('request')])
PatternExpr_1796 = da.pat.FreePattern('Coordinator')
PatternExpr_2128 = da.pat.TuplePattern([da.pat.ConstantPattern('readAttr'), da.pat.FreePattern('request')])
PatternExpr_2135 = da.pat.FreePattern('Coordinator')
PatternExpr_2238 = da.pat.TuplePattern([da.pat.ConstantPattern('update-decision'), da.pat.FreePattern('request')])
PatternExpr_2245 = da.pat.FreePattern('Worker')
PatternExpr_2684 = da.pat.TuplePattern([da.pat.ConstantPattern('restart'), da.pat.FreePattern('request')])
PatternExpr_2691 = da.pat.FreePattern('Coordinator')
PatternExpr_1115 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.TuplePattern([da.pat.ConstantPattern('terminate')])])
PatternExpr_467 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.TuplePattern([da.pat.ConstantPattern('cached')])])
_config_object = {}
import random
import time
from configparser import ConfigParser
from VersionDB import latestVersionBefore
from VersionDB import print_version
from VersionDB import update_latest_Version

class Coordinator(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._CoordinatorReceivedEvent_0 = []
        self._CoordinatorReceivedEvent_1 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_CoordinatorReceivedEvent_0', PatternExpr_462, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_CoordinatorReceivedEvent_1', PatternExpr_1110, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_CoordinatorReceivedEvent_2', PatternExpr_1176, sources=[PatternExpr_1183], destinations=None, timestamps=None, record_history=None, handlers=[self._Coordinator_handler_1175]), da.pat.EventPattern(da.pat.ReceivedEvent, '_CoordinatorReceivedEvent_3', PatternExpr_1411, sources=[PatternExpr_1418], destinations=None, timestamps=None, record_history=None, handlers=[self._Coordinator_handler_1410]), da.pat.EventPattern(da.pat.ReceivedEvent, '_CoordinatorReceivedEvent_4', PatternExpr_1789, sources=[PatternExpr_1796], destinations=None, timestamps=None, record_history=None, handlers=[self._Coordinator_handler_1788]), da.pat.EventPattern(da.pat.ReceivedEvent, '_CoordinatorReceivedEvent_5', PatternExpr_2128, sources=[PatternExpr_2135], destinations=None, timestamps=None, record_history=None, handlers=[self._Coordinator_handler_2127]), da.pat.EventPattern(da.pat.ReceivedEvent, '_CoordinatorReceivedEvent_6', PatternExpr_2238, sources=[PatternExpr_2245], destinations=None, timestamps=None, record_history=None, handlers=[self._Coordinator_handler_2237]), da.pat.EventPattern(da.pat.ReceivedEvent, '_CoordinatorReceivedEvent_7', PatternExpr_2684, sources=[PatternExpr_2691], destinations=None, timestamps=None, record_history=None, handlers=[self._Coordinator_handler_2683])])

    def setup(self, coordinator_id, client_dict, coordinator_dict, database, no_of_coordinators, no_of_workers_per_coordinator, dedicated_workers_dict, config_file, **rest_2928):
        super().setup(coordinator_id=coordinator_id, client_dict=client_dict, coordinator_dict=coordinator_dict, database=database, no_of_coordinators=no_of_coordinators, no_of_workers_per_coordinator=no_of_workers_per_coordinator, dedicated_workers_dict=dedicated_workers_dict, config_file=config_file, **rest_2928)
        self._state.coordinator_id = coordinator_id
        self._state.client_dict = client_dict
        self._state.coordinator_dict = coordinator_dict
        self._state.database = database
        self._state.no_of_coordinators = no_of_coordinators
        self._state.no_of_workers_per_coordinator = no_of_workers_per_coordinator
        self._state.dedicated_workers_dict = dedicated_workers_dict
        self._state.config_file = config_file
        self.output((('Coordinator ' + str(self._state.coordinator_id)) + ' is being setup'))
        self._state.coordinator_id = self._state.coordinator_id
        self._state.client_dict = self._state.client_dict
        self._state.database = self._state.database
        self._state.coordinator_dict = self._state.coordinator_dict
        self._state.no_of_coordinators = self._state.no_of_coordinators
        self._state.no_of_workers_per_coordinator = self._state.no_of_workers_per_coordinator
        self._state.config_file = self._state.config_file
        self._state.dedicated_workers_dict = self._state.dedicated_workers_dict
        self._state.subject_request_list = []
        self._state.resource_request_list = []
        self._state.subject_cache = {}
        self._state.resource_cache = {}
        self._state.def_read_attr_file = ''
        self._state.might_read_attr_file = ''
        self._state.def_read_attr_map = {}
        self._state.might_read_attr_map = {}
        self._state.list_version = []
        self._state.cacheDB = {}
        self._state.global_request_id = ((self._state.coordinator_id * 1000) + 1)

    def run(self):
        self.loadDBCache()
        self.get_configuration()
        (self._state.def_read_attr_map, self._state.might_read_attr_map) = self.get_attribute_classification(self._state.def_read_attr_file, self._state.might_read_attr_file)
        self.output(('def_read_attr_map' + str(self._state.def_read_attr_map)))
        self.output(('might_read_attr_map' + str(self._state.might_read_attr_map)))
        self.output((('Coordinator ' + str(self._state.coordinator_id)) + ' coming up...'))
        super()._label('_st_label_1107', block=False)
        _st_label_1107 = 0
        while (_st_label_1107 == 0):
            _st_label_1107 += 1
            if PatternExpr_1115.match_iter(self._CoordinatorReceivedEvent_1, SELF_ID=self._id):
                _st_label_1107 += 1
            else:
                super()._label('_st_label_1107', block=True)
                _st_label_1107 -= 1
        self.output('Termination has started')
        self.output(('Subject CacheDB: ' + str(self._state.subject_cache)))
        self.output(('Resource CacheDB: ' + str(self._state.resource_cache)))
        self.output('Version DB')
        for version in self._state.list_version:
            self.output('Printing Version Database')
            print_version(version)
        for i in range(len(self._state.dedicated_workers_dict)):
            self.send(('terminate',), to=self._state.dedicated_workers_dict[i])
        self.output(('Terminated Coordinator:' + str(self._state.coordinator_id)))

    def get_attribute_classification(self, def_read_attr_conf, might_read_attr_conf):
        self._state.def_read_attr_map = {}
        self._state.might_read_attr_map = {}
        with open(def_read_attr_conf) as f:
            lines = f.readlines()
            for line in lines:
                val = line.split(' --> ')
                def_keys = val[0].split(',')
                def_read_attr = val[1].split(',')
                self._state.def_read_attr_map.update({(def_keys[0], def_keys[1], def_keys[2]): def_read_attr})
        with open(might_read_attr_conf) as f:
            lines = f.readlines()
            for line in lines:
                val = line.split(' --> ')
                might_keys = val[0].split(',')
                might_read_attr = val[1].split(',')
                self._state.might_read_attr_map.update({(might_keys[0], might_keys[1], might_keys[2]): might_read_attr})
        return (self._state.def_read_attr_map, self._state.might_read_attr_map)

    def loadDBCache(self):
        self.output('Initial DB Cache Load')
        self.send(('read', self._state.coordinator_id, 'dump', 0), to=self._state.database)
        super()._label('_st_label_459', block=False)
        _st_label_459 = 0
        while (_st_label_459 == 0):
            _st_label_459 += 1
            if PatternExpr_467.match_iter(self._CoordinatorReceivedEvent_0, SELF_ID=self._id):
                _st_label_459 += 1
            else:
                super()._label('_st_label_459', block=True)
                _st_label_459 -= 1
        self.output('Cache Loaded')

    def determineWorker(self):
        self.output(('No. of workers per Coordinator ' + str(self._state.no_of_workers_per_coordinator)))
        w_id = random.randint(0, (self._state.no_of_workers_per_coordinator - 1))
        self.output(('w_id: ' + str(w_id)))
        return w_id

    def determineCoordinator2(self, request, obj_type, no_of_coordinators):
        coord_id = 1
        if (obj_type == 'subject'):
            coord_id = ((hash(request['subject_id']) % no_of_coordinators) + 1)
        elif (obj_type == 'resource'):
            coord_id = ((hash(request['resource_id']) % no_of_coordinators) + 1)
        return coord_id

    def obj(self, request, i):
        if (i == 1):
            return 'subject'
        elif (i == 2):
            return 'resource'

    def now(self):
        return time.time()

    def defReadAttr(self, obj_type, request):
        self.output('Reading Def Read Attribute')
        if ((request['subject_id'], request['resource_id'], request['action_id']) in self._state.def_read_attr_map):
            attr_list = self._state.def_read_attr_map[(request['subject_id'], request['resource_id'], request['action_id'])]
            def_read_attr_list = []
            for attrs in attr_list:
                attr = attrs.split('.')
                if ((obj_type == 'subject') and (attr[0] == 'subject')):
                    def_read_attr_list.append(attr[1])
                elif ((obj_type == 'resource') and (attr[0] == 'resource')):
                    def_read_attr_list.append(attr[1])
            return def_read_attr_list
        else:
            return []

    def mightReadAttr(self, obj_type, request):
        self.output('Reading Might Read Attribute')
        if ((request['subject_id'], request['resource_id'], request['action_id']) in self._state.might_read_attr_map):
            attr_list = self._state.might_read_attr_map[(request['subject_id'], request['resource_id'], request['action_id'])]
            might_read_attr_list = []
            for attrs in attr_list:
                attr = attrs.split('.')
                if ((obj_type == 'subject') and (attr[0] == 'subject')):
                    might_read_attr_list.append(attr[1])
                elif ((obj_type == 'resource') and (attr[0] == 'resource')):
                    might_read_attr_list.append(attr[1])
            return might_read_attr_list
        else:
            return []

    def get_configuration(self):
        self.output('Reading Configuration from properties file')
        config = ConfigParser()
        config.read(self._state.config_file)
        self._state.def_read_attr_file = config.get('SystemConfiguration', 'def_read_attr_file')
        self._state.might_read_attr_file = config.get('SystemConfiguration', 'might_read_attr_file')

    def cachedUpdates(self, this_obj, request):
        list_subject = []
        list_resource = []
        if (this_obj == 'subject'):
            s_id = request['subject_id']
            current_record = self._state.subject_cache[s_id]
            status_version_list = current_record[1]
            history_version_list = current_record[2]
            for version in status_version_list:
                if (version[1] < request['timestamp']):
                    list_subject.append(version)
            for version in history_version_list:
                if (version[1] < request['timestamp']):
                    list_subject.append(version)
        elif (this_obj == 'resource'):
            r_id = request['resource_id']
            current_record = self._state.resource_cache[r_id]
            account_bal_version_list = current_record[0]
            for version in account_bal_version_list:
                if (version[1] < request['timestamp']):
                    list_resource.append(version)
        return (list_subject, list_resource)

    def performCacheUpdates(self, request):
        updatedAttr = request['updatedAttr']
        if (request['updatedObj'] == 'subject'):
            current_record = self._state.subject_cache[request['subject_id']]
            for attr in updatedAttr[0]:
                if (attr == 'history'):
                    current_record[2].append((value, request['timestamp']))
                    current_record[2] = sorted(current_record[2], key=(lambda tup: tup[1]), reversed=True)
                elif (attr == 'status'):
                    current_record[1].append((value, request['timestamp']))
                    current_record[1] = sorted(current_record[1], key=(lambda tup: tup[1]), reversed=True)
            self._state.subject_cache.update({request['subject_id']: (current_record[0], current_record[1], current_record[2])})
        elif (request['updatedObj'] == 'resource'):
            r_id = request['resource_id']
            current_record = self._state.resource_cache[r_id]
            for (attr, value) in updatedAttr:
                if (attr == 'account_bal'):
                    current_record[0].append((value, request['timestamp']))
                    current_record[0] = sorted(current_record[0], key=(lambda tup: tup[1]), reversed=True)
            self._state.resource_cache.update({r_id: (current_record[0], current_record[1], current_record[2])})

    def noPendingMightWriteAttr(self, attr_list, this_obj, timestamp, request):
        i = 0
        while True:
            if (i < 5):
                self.output('Waiting to Prevent Starvation')
                self.output(((('Waiting Request: ' + str(request['req_id'])) + ' from Client: ') + str(request['client_id'])))
                i += 1
            flag = True
            for attr in attr_list:
                if latestVersionBefore(self._state.list_version, this_obj, attr, timestamp).pendingMightWrite:
                    flag = False
            if ((time.time() - timestamp) > 5):
                return True
            if (flag == True):
                return True

    def noPendingMightReadAttr(self, attr_list, this_obj, timestamp, request):
        timestamp = time.time()
        i = 0
        while True:
            if (i < 5):
                self.output('Write Request is Pending')
                i += 1
            flag = True
            for attr in attr_list:
                list = latestVersionBefore(self._state.list_version, this_obj, attr, timestamp)
                if (list and list.pendingMightRead):
                    self.output(((('Length of Pending Might Read for attribute: ' + str(attr)) + ' is ') + str(len([set(list.pendingMightRead)]))))
                if (list and (not (list.pendingMightRead == [])) and (not (len([set(list.pendingMightRead)]) == 1))):
                    flag = False
            if ((time.time() - timestamp) > 5):
                return True
            if (flag == True):
                self.output('Exiting await......')
                return True

    def restart(self, request):
        self.send(('restart', request), to=self._state.coordinator_dict[self._state.coordinator_id])

    def get_db_tuple(self, request):
        attr = request['updatedAttr']
        tuple = ()
        if (request['updatedObj'] == 'subject'):
            if (attr[0] == 'status'):
                tuple = (request['subject_id'], None, attr[1], None)
            elif (attr[0] == 'history'):
                tuple = (request['subject_id'], None, None, attr[1])
        elif (attr[0] == 'account_bal'):
            tuple = (request['resource_id'], attr[1], None, None)
        return tuple

    def checkForConflicts(self, object, request):
        i = 0
        for attr in request['updatedAttr']:
            if ((i % 2) == 0):
                v = latestVersionBefore(self._state.list_version, object, attr, request['timestamp'])
                if (v and (int(v.read_timestamp) >= int(request['timestamp']))):
                    return True
            i += 1
        return False

    def _Coordinator_handler_1175(self, data, Database):
        self.output('Receiving data dump from DB')
        self.output(('Subject List : ' + str(data[0])))
        self.output(('Resource List : ' + str(data[1])))
        self._state.subject_cache = data[0]
        self._state.resource_cache = data[1]
        self.output(('Subject cache : ' + str(self._state.subject_cache)))
        self.output(('Resource cache : ' + str(self._state.resource_cache)))
        self.send(('cached',), to=self._state.coordinator_dict[self._state.coordinator_id])
    _Coordinator_handler_1175._labels = None
    _Coordinator_handler_1175._notlabels = None

    def _Coordinator_handler_1410(self, request, Client):
        self.output(((((('Coord ' + str(self._state.coordinator_id)) + ' received Policy Evaluation Request from Client ') + str(request['client_id'])) + ' for request: ') + str(request['req_id'])))
        self.output(('Request Message: ' + str(request)))
        obj_type = 'resource'
        this_obj = 'subject'
        timestamp = time.time()
        attr_list = []
        for attribute in self.defReadAttr(this_obj, request):
            attr_list.append(attribute)
        for attribute in self.mightReadAttr(this_obj, request):
            attr_list.append(attribute)
        self.output('Preventing Starvation of Write due to Read Request')
        super()._label('_st_label_1494', block=False)
        _st_label_1494 = 0
        while (_st_label_1494 == 0):
            _st_label_1494 += 1
            if (self.noPendingMightWriteAttr(attr_list, this_obj, timestamp, request) == True):
                _st_label_1494 += 1
            else:
                super()._label('_st_label_1494', block=True)
                _st_label_1494 -= 1
        self.output('Exiting AWAIT.....!!!!')
        request.update({'coord_id1': self._state.coordinator_id})
        request.update({'global_request_id': self._state.global_request_id})
        self._state.global_request_id = (self._state.global_request_id + 1)
        timestamp = time.time()
        request.update({'timestamp': timestamp})
        if (request['might_update_obj'] == ''):
            for attribute in self.defReadAttr(this_obj, request):
                latestVersionBefore(self._state.list_version, this_obj, attribute, request['timestamp']).read_timestamp = request['timestamp']
            for attribute in self.mightReadAttr(this_obj, request):
                v = latestVersionBefore(self._state.list_version, this_obj, attribute, request['timestamp'])
                if (v and v.pendingMightRead):
                    v.pendingMightRead.append(request['req_id'])
        else:
            request.update({'coord_id1': self._state.coordinator_id})
            request.update({'global_request_id': self._state.global_request_id})
            self._state.global_request_id = (self._state.global_request_id + 1)
            timestamp = time.time()
            request.update({'timestamp': timestamp})
            if (request['might_update_obj'] == 1):
                obj_type = 'resource'
                this_obj = 'subject'
            else:
                obj_type = 'subject'
                this_obj = 'resource'
            attr_list = []
            for attribute in self.defReadAttr(this_obj, request):
                attr_list.append(attribute)
            for attribute in self.mightReadAttr(this_obj, request):
                attr_list.append(attribute)
            for attribute in attr_list:
                v = latestVersionBefore(self._state.list_version, this_obj, attribute, request['timestamp'])
                if (v and v.pendingMightRead):
                    v.pendingMightRead.append(request['req_id'])
        cache_updates = self.cachedUpdates(this_obj, request)
        if (this_obj == 'subject'):
            request.update({'sub_cache_updates': cache_updates[0]})
        elif (this_obj == 'resource'):
            request.update({'res_cache_updates': cache_updates[1]})
        coord_id2 = self.determineCoordinator2(request, obj_type, self._state.no_of_coordinators)
        request.update({'coord_id2': coord_id2})
        self.output(((((((('Coord ' + str(request['coord_id1'])) + ' is sending request ') + str(request['req_id'])) + ' from client ') + str(request['client_id'])) + ' to coord ') + str(request['coord_id2'])))
        self.send(('coord2_policy_eval', request), to=self._state.coordinator_dict[request['coord_id2']])
    _Coordinator_handler_1410._labels = None
    _Coordinator_handler_1410._notlabels = None

    def _Coordinator_handler_1788(self, request, Coordinator):
        self.output(((((('Coord ' + str(self._state.coordinator_id)) + ' received Policy Evaluation Request from Coordinator ') + str(request['coord_id1'])) + ' for request: ') + str(request['req_id'])))
        self.output(('Request Message from Coordinator: ' + str(request)))
        if (request['might_update_obj'] == ''):
            this_obj = 'resource'
            for attribute in self.defReadAttr(this_obj, request):
                latestVersionBefore(self._state.list_version, this_obj, attribute, request['timestamp']).read_timestamp = request['timestamp']
            for attribute in self.mightReadAttr(this_obj, request):
                v = latestVersionBefore(self._state.list_version, this_obj, attribute, request['timestamp'])
                if (v and v.pendingMightRead):
                    v.pendingMightRead.append(request['req_id'])
            attr_list = []
            for attribute in self.defReadAttr(this_obj, request):
                attr_list.append(attribute)
            for attribute in self.mightReadAttr(this_obj, request):
                attr_list.append(attribute)
        else:
            if (request['might_update_obj'] == 1):
                this_obj = 'subject'
            else:
                this_obj = 'resource'
            attr_list = []
            for attribute in self.defReadAttr(this_obj, request):
                attr_list.append(attribute)
            for attribute in self.mightReadAttr(this_obj, request):
                attr_list.append(attribute)
            for attribute in attr_list:
                latestVersionBefore(self._state.list_version, this_obj, attribute, request['timestamp']).pendingMightRead.append(request['req_id'])
        cache_updates = self.cachedUpdates(this_obj, request)
        if (this_obj == 'subject'):
            request.update({'sub_cache_updates': cache_updates[0]})
        elif (this_obj == 'resource'):
            request.update({'res_cache_updates': cache_updates[1]})
        w_id = self.determineWorker()
        request.update({'w_id': w_id})
        self.output(((('Assigned worker ' + str(w_id)) + ' to request: ') + str(request['req_id'])))
        self.send(('evaluate_policy', request), to=self._state.dedicated_workers_dict[request['w_id']])
    _Coordinator_handler_1788._labels = None
    _Coordinator_handler_1788._notlabels = None

    def _Coordinator_handler_2127(self, request, Coordinator):
        for attribute in self.mightReadAttr(object, request):
            v = latestVersionBefore(object, attribute, request['timestamp'])
            if (request['req_id'] in v.pendingMightRead):
                v.pendingMightRead.remove(request['req_id'])
            if (attribute in request[('readAttr' + request['updatedObj'])]):
                v.read_timestamp = request['timestamp']
        for attribute in self.defReadAttr(object, request):
            v = latestVersionBefore(object, attribute, request['timestamp'])
            if (request['req_id'] in v.pendingMightRead):
                v.pendingMightRead.remove(request['req_id'])
            if (attribute in request[('readAttr' + str(request['updatedObj']))]):
                v.read_timestamp = request['timestamp']
    _Coordinator_handler_2127._labels = None
    _Coordinator_handler_2127._notlabels = None

    def _Coordinator_handler_2237(self, request, Worker):
        self.output((((((('Coordinator ' + str(self._state.coordinator_id)) + ' received decision [Request: ') + str(request['req_id'])) + ' , Client: ') + str(request['client_id'])) + '] from Worker'))
        self.output(('Request Message: ' + str(request)))
        object = request['object']
        if (not request['updatedObj']):
            self.output('Inside coordinator while returning from worker')
            for attr in self.mightReadAttr(object, request):
                v = latestVersionBefore(self._state.list_version, object, attr, request['timestamp'])
                if v.pendingMightRead:
                    if (request['req_id'] in v.pendingMightRead):
                        v.pendingMightRead.remove(request['req_id'])
                    if (attr in request[('readAttr' + request['object'])]):
                        v.read_timestamp = request['timestamp']
            self.output('Done with coordinator while returning from worker')
        else:
            for attr in request['updatedAttr']:
                v = latestVersionBefore(self._state.list_version, object, attr, request['timestamp'])
                if v:
                    v.pendingMightWrite.append(request['req_id'])
            self.output('Checking for conflict')
            conflict = self.checkForConflicts(object, request)
            self.output(((((('Conflict  Before Await Check for request id: ' + str(request['req_id'])) + ' from client id: ') + str(request['client_id'])) + ' -> ') + str(conflict)))
            if (not conflict):
                attr_list = []
                attr_list.append(request['updatedAttr'][0])
                super()._label('_st_label_2418', block=False)
                _st_label_2418 = 0
                while (_st_label_2418 == 0):
                    _st_label_2418 += 1
                    if (self.noPendingMightReadAttr(attr_list, request['updatedObj'], request['timestamp'], request) == True):
                        _st_label_2418 += 1
                    else:
                        super()._label('_st_label_2418', block=True)
                        _st_label_2418 -= 1
                self.output('Checking Again for conflict')
                conflict = self.checkForConflicts(object, request)
                self.output(((((('Conflict Check After Await for request id: ' + str(request['req_id'])) + ' from client id: ') + str(request['client_id'])) + ' -> ') + str(conflict)))
                if (not conflict):
                    self.send(('write', self._state.coordinator_id, request['updatedObj'], self.get_db_tuple(request)), to=self._state.database)
                    self.performCacheUpdates(request)
                    update_latest_Version(self._state.list_version, request['object'], request['updatedAttr'], request['timestamp'], request['timestamp'])
                    for attribute in self.mightReadAttr(object, request):
                        v = latestVersionBefore(self._state.list_version, object, attribute, request['timestamp'])
                        if (v and v.pendingMightRead):
                            self.output('Removing Pending Might Read')
                            if (request['req_id'] in v.pendingMightRead):
                                v.pendingMightRead.remove(request['req_id'])
                            if (attribute in request[('readAttr' + request['updatedObj'])]):
                                v.read_timestamp = request['timestamp']
                    for attribute in self.defReadAttr(object, request):
                        v = latestVersionBefore(self._state.list_version, object, attribute, request['timestamp'])
                        if (v and v.pendingMightRead):
                            self.output('Removing Pending def Read')
                            if (request['req_id'] in v.pendingMightRead):
                                v.pendingMightRead.remove(request['req_id'])
                            if (attribute in request[('readAttr' + str(request['updatedObj']))]):
                                v.read_timestamp = request['timestamp']
                    self.output('Removing data from Pending Might Write')
                    for attribute in request['updatedAttr']:
                        v = latestVersionBefore(self._state.list_version, object, attribute, request['timestamp'])
                        if (v and v.pendingMightWrite and (request['req_id'] in v.pendingMightWrite)):
                            v.pendingMightWrite.remove(request['req_id'])
                    self.output('Sending update decision to client')
                    self.send(('update-decision', request), to=self._state.client_dict[request['client_id']])
                    self.output('Sending Decision to readonly obj')
                    self.send(('readAttr', request, request['readonlyObj']), to=self._state.coordinator_dict[request['coord_id2']])
                else:
                    self.restart(request)
            else:
                self.restart(request)
    _Coordinator_handler_2237._labels = None
    _Coordinator_handler_2237._notlabels = None

    def _Coordinator_handler_2683(self, request, Coordinator):
        self.output(((('Restarting the request id: ' + str(request['req_id'])) + ' For client id: ') + str(request['client_id'])))
        v = latestVersionBefore(self._state.list_version, request['object'], request['updatedAttr'], request['timestamp'])
        if (v and v.pendingMightRead and v.pendingMightWrite):
            if (request['req_id'] in v.pendingMightRead):
                v.pendingMightRead.remove(request['req_id'])
            if (request['req_id'] in v.pendingMightWrite):
                v.pendingMightWrite.remove(request['req_id'])
        timestamp = time.time()
        request['timestamp'] = timestamp
        for attribute in self.mightReadAttr(request['object'], request):
            v = latestVersionBefore(self._state.list_version, object, attribute, request['timestamp'])
            v.pendingMightRead.append(request['req_id'])
        for attribute in self.defReadAttr(request['object'], request):
            v = latestVersionBefore(self._state.list_version, object, attribute, request['timestamp'])
            v.pendingMightRead.append(request['req_id'])
        cache_updates = self.cachedUpdates(request['object'], request)
        if (request['object'] == 'subject'):
            request.update({'sub_cache_updates': cache_updates[0]})
        elif (request['object'] == 'resource'):
            request.update({'res_cache_updates': cache_updates[1]})
        self.send(('coord2_policy_eval', request), to=self._state.coordinator_dict[request['coord_id2']])
    _Coordinator_handler_2683._labels = None
    _Coordinator_handler_2683._notlabels = None
