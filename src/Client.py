# -*- generated by 1.0.4 -*-
import da
PatternExpr_1115 = da.pat.TuplePattern([da.pat.ConstantPattern('terminate')])
PatternExpr_1141 = da.pat.ConstantPattern('send_req')
PatternExpr_1145 = da.pat.FreePattern('Client')
PatternExpr_1208 = da.pat.TuplePattern([da.pat.ConstantPattern('update-decision'), da.pat.FreePattern('request')])
PatternExpr_1215 = da.pat.FreePattern('Coordinator')
PatternExpr_1268 = da.pat.TuplePattern([da.pat.ConstantPattern('read-decision'), da.pat.FreePattern('req_id'), da.pat.FreePattern('decision')])
PatternExpr_1277 = da.pat.FreePattern('Worker')
PatternExpr_1312 = da.pat.TuplePattern([da.pat.ConstantPattern('decision-perf-eval'), da.pat.FreePattern('req_id')])
PatternExpr_1319 = da.pat.FreePattern('Coordinator')
PatternExpr_1120 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.TuplePattern([da.pat.ConstantPattern('terminate')])])
_config_object = {}
import sys
import random
from configparser import ConfigParser
import time
import xml.etree.ElementTree as ET
import csv

class Client(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._ClientReceivedEvent_0 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_0', PatternExpr_1115, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_1', PatternExpr_1141, sources=[PatternExpr_1145], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_1140]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_2', PatternExpr_1208, sources=[PatternExpr_1215], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_1207]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_3', PatternExpr_1268, sources=[PatternExpr_1277], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_1267]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_4', PatternExpr_1312, sources=[PatternExpr_1319], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_1311])])

    def setup(self, client_id, coordinator_dict, client_dict, master, config_file, **rest_1419):
        super().setup(client_id=client_id, coordinator_dict=coordinator_dict, client_dict=client_dict, master=master, config_file=config_file, **rest_1419)
        self._state.client_id = client_id
        self._state.coordinator_dict = coordinator_dict
        self._state.client_dict = client_dict
        self._state.master = master
        self._state.config_file = config_file
        self.output((('Client ' + str(self._state.client_id)) + ' coming up...'))
        self._state.client_id = self._state.client_id
        self._state.client_dict = self._state.client_dict
        self._state.coordinator_dict = self._state.coordinator_dict
        self._state.master = self._state.master
        self._state.config_file = self._state.config_file
        self._state.request_list = []
        self._state.information_map = {}
        self._state.nrequests = 0
        self._state.sent_request_queue = []
        self._state.policy = {}
        self._state.prediction = True
        self._state.start_time = 0
        self._state.end_time = 0
        self._state.perf_eval_data = []

    def run(self):
        self.output((('Client ' + str(self._state.client_id)) + ' coming up...'))
        config = ConfigParser()
        config.read(self._state.config_file)
        policy_file = config.get('SystemConfiguration', 'policy_file')
        self._state.policy = self.parse_xml(policy_file)
        client_config = self.readConfigData()
        self._state.nrequests = client_config['client_workload']
        self.output(((('Number of requests to be created for Client ' + str(self._state.client_id)) + ':') + str(self._state.nrequests)))
        ncoordinators = client_config['no_of_coordinators']
        request_data = client_config['request_data']
        self._state.request_list = []
        for i in range(self._state.nrequests):
            request = {}
            req_id = (i + 1)
            (sub_id, res_id, action_id) = request_data[i]
            request.update({'client_id': self._state.client_id})
            request.update({'req_id': req_id})
            request.update({'subject_id': sub_id})
            request.update({'resource_id': res_id})
            request.update({'action_id': action_id})
            request_type = self.requestType(request)
            if (request_type == 'Read'):
                obj_type = 'Subject'
                request.update({'might_update_obj': ''})
            elif (request_type == 'Update'):
                upd_obj = self._state.information_map[(sub_id, res_id, action_id)]
                obj_type = ''
                if (i == 1):
                    obj_type = 'resource'
                else:
                    obj_type = 'subject'
                coord_id1 = self.determineCoordinator1(request, obj_type, ncoordinators)
                if (upd_obj == 'subject'):
                    obj_type = 'resource'
                elif (upd_obj == 'resource'):
                    obj_type = 'subject'
                if (self._state.prediction == '1'):
                    if (upd_obj == 'subject'):
                        request.update({'wrong_coord': 1})
                    else:
                        request.update({'wrong_coord': 2})
                    (upd_obj, obj_type) = (obj_type, upd_obj)
                request.update({'might_update_obj': upd_obj})
            coord_id1 = self.determineCoordinator1(request, obj_type, ncoordinators)
            request.update({'coord_id1': coord_id1})
            self._state.request_list.append(request)
        time.sleep(5)
        self.send('send_req', to=self._state.client_dict[self._state.client_id])
        super()._label('_st_label_1112', block=False)
        _st_label_1112 = 0
        while (_st_label_1112 == 0):
            _st_label_1112 += 1
            if PatternExpr_1120.match_iter(self._ClientReceivedEvent_0, SELF_ID=self._id):
                _st_label_1112 += 1
            else:
                super()._label('_st_label_1112', block=True)
                _st_label_1112 -= 1
        self.output(('Terminated Client: ' + str(self._state.client_id)))
        self.output('Successfully Terminated Client Processes...')

    def get_request_list(self, request_seq):
        requests = request_seq.split(':')
        for request in requests:
            attr = request.split(',')
            sub_id = attr[0].strip()
            res_id = attr[1].strip()
            action = attr[2].strip()
            self._state.request_list.append((sub_id, res_id, action))
        self.output(('Request List: ' + str(self._state.request_list)))
        return self._state.request_list

    def get_random_request_list(self, subject, resource, action, list_size):
        subjects = subject.split(', ')
        self.output(subject)
        self.output(subjects)
        resources = resource.split(', ')
        actions = action.split(', ')
        self._state.request_list = []
        for i in range(list_size):
            subj = subjects[random.randint(0, (len(subjects) - 1))]
            res = resources[random.randint(0, (len(resources) - 1))]
            act = actions[random.randint(0, (len(actions) - 1))]
            self._state.request_list.append((subj, res, act))
        self.output(('Request List: ' + str(self._state.request_list)))
        return self._state.request_list

    def readConfigData(self):
        config = ConfigParser()
        config.read(self._state.config_file)
        dict = {}
        no_of_coordinators = config.get('SystemConfiguration', 'no_of_coordinators')
        dict.update({'no_of_coordinators': int(no_of_coordinators)})
        client_workload = config.get('ClientConfiguration', 'client_workload')
        dict.update({'client_workload': int(client_workload)})
        sequence_type = config.get('ClientConfiguration', 'sequence_type')
        dict.update({'sequence_type': sequence_type})
        self._state.prediction = config.get('SystemConfiguration', 'prediction')
        if (sequence_type == 'RANDOM'):
            sequence_seed = config.get('ClientConfiguration', 'sequence_seed')
            random.seed(sequence_seed)
            request_data = self.get_random_request_list(config.get('Data', 'subjects'), config.get('Data', 'resources'), config.get('Data', 'actions'), int(client_workload))
        else:
            request_data = self.get_request_list(config.get('Data', 'request_data'))
        dict.update({'request_data': request_data})
        self.output(('len of req_data: ' + str(len(request_data))))
        for request in request_data:
            upd_obj = self.mightWriteObj(request)
            self.output(('Upd obj: ' + str(upd_obj)))
            if (request[2] == 'update'):
                self.output(('action: ' + str(request[2])))
                self._state.information_map.update({request: upd_obj})
        self.output(('information_map: ' + str(self._state.information_map)))
        return dict

    def requestType(self, request):
        aid = request['action_id']
        if (aid == 'read'):
            return 'Read'
        else:
            return 'Update'

    def parse_xml(self, file_path):
        tree = ET.parse(file_path)
        root = tree.getroot()
        dict = {}
        for rule in root.iter('rule'):
            sub_id = ''
            res_id = ''
            sc = rule[0].attrib
            if sc:
                sub_id = sc['customer_id']
            rc = rule[1].attrib
            if rc:
                res_id = rc['account_id']
            act = rule.find('action')
            action = act.attrib['name']
            if ((len(rule) == 4) and ('subjectUpdate' in rule[3].tag)):
                dict.update({(sub_id, res_id, action): 'subjectUpdate'})
            elif ((len(rule) == 4) and ('resourceUpdate' in rule[3].tag)):
                dict.update({(sub_id, res_id, action): 'resourceUpdate'})
        return dict

    def mightWriteObj(self, request):
        self.output(('request: ' + str(request)))
        if (request in self._state.policy):
            if (self._state.policy[request] == 'subjectUpdate'):
                return 'subject'
            elif (self._state.policy[request] == 'resourceUpdate'):
                return 'resource'
        else:
            return ''

    def obj(self, i):
        if (i == 1):
            return 'subject'
        if (i == 2):
            return 'resource'

    def determineCoordinator1(self, request, obj_type, no_of_coordinators):
        coord_id = 1
        if (obj_type == 'subject'):
            coord_id = ((hash(request['subject_id']) % no_of_coordinators) + 1)
        elif (obj_type == 'resource'):
            coord_id = ((hash(request['resource_id']) % no_of_coordinators) + 1)
        return coord_id

    def _Client_handler_1140(self, Client):
        request = {}
        next_req_index = len(self._state.sent_request_queue)
        request = self._state.request_list[next_req_index]
        self.output(((((('Client ' + str(request['client_id'])) + ' sending request ') + str((next_req_index + 1))) + ' to coordinator') + str(request['coord_id1'])))
        self._state.start_time = time.time()
        self.send(('coord1_policy_eval', request), to=self._state.coordinator_dict[request['coord_id1']])
        self._state.sent_request_queue.append(request)
    _Client_handler_1140._labels = None
    _Client_handler_1140._notlabels = None

    def _Client_handler_1207(self, request, Coordinator):
        self.output(((('client ' + str(self._state.client_id)) + 'got the decision for update request: ') + str(request['req_id'])))
        self._state.information_map.update({(request['subject_id'], request['resource_id'], request['action_id']): request['updatedObj']})
        if (len(self._state.sent_request_queue) < self._state.nrequests):
            self.send('send_req', to=self._state.client_dict[self._state.client_id])
        else:
            self.send(('exhausted',), to=self._state.master)
    _Client_handler_1207._labels = None
    _Client_handler_1207._notlabels = None

    def _Client_handler_1267(self, req_id, decision, Worker):
        self.output(((('client ' + str(self._state.client_id)) + ' got the decision for read request: ') + str(req_id)))
        if (len(self._state.sent_request_queue) < self._state.nrequests):
            self.send('send_req', to=self._state.client_dict[self._state.client_id])
        else:
            self.output('exhausted')
            self.send(('exhausted',), to=self._state.master)
    _Client_handler_1267._labels = None
    _Client_handler_1267._notlabels = None

    def _Client_handler_1311(self, req_id, Coordinator):
        self.output(((('client ' + str(self._state.client_id)) + 'got the decision for update request: ') + str('req_id')))
        self._state.end_time = time.time()
        time_taken = (self._state.end_time - self._state.start_time)
        self.output(((('[Request ' + str(req_id)) + '] EVAL TIME: ') + str(time_taken)))
        self._state.perf_eval_data.append(time_taken)
        if (len(self._state.sent_request_queue) < self._state.nrequests):
            self.send('send_req', to=self._state.client_dict[self._state.client_id])
        else:
            with open('perf_eval_data_ph4.csv', 'w') as csvfile:
                fieldnames = ['time_taken']
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                writer.writeheader()
                self.output(str(self._state.perf_eval_data))
                for item in self._state.perf_eval_data:
                    writer.writerow({'time_taken': item})
            self.output('exhausted')
            self.send(('exhausted',), to=self._state.master)
    _Client_handler_1311._labels = None
    _Client_handler_1311._notlabels = None
